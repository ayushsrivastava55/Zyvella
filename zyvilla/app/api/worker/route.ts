import { NextResponse } from 'next/server';
import { Queue, Worker } from 'bullmq';
import Redis from 'ioredis';
import { fal } from '@fal-ai/client';

// Configure FAL.ai
fal.config({
  credentials: process.env.FAL_KEY!,
});

// Redis connection
const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  username: process.env.REDIS_USERNAME,
  password: process.env.REDIS_PASSWORD,
  tls: process.env.REDIS_TLS === 'true' ? {} : undefined,
  maxRetriesPerRequest: 3,
  lazyConnect: true,
});

const imageQueue = new Queue('image-generation', { 
  connection: redis,
  defaultJobOptions: {
    removeOnComplete: 10,
    removeOnFail: 5,
  }
});

// Remove background from person's image
async function removePersonBackground(imageUrl: string): Promise<string> {
  console.log("üñºÔ∏è  Removing background from person's image using Fal.ai");
  
  try {
    const result = await fal.subscribe("fal-ai/imageutils/rembg", {
      input: {
        image_url: imageUrl
      }
    });

    if (!result.data?.image?.url) {
      throw new Error("Background removal failed - no processed image returned");
    }

    return result.data.image.url;
  } catch (error) {
    console.error("‚ùå Background removal failed:", error);
    throw error;
  }
}

// Generate image with jewelry reference
async function generateWithJewelryReference(jewelryImageUrl: string, prompt: string): Promise<string> {
  console.log(`üé® Generating image with exact jewelry reference using FLUX Kontext Pro`);
  
  try {
    const enhancedPrompt = `${prompt}, wearing this exact piece of jewelry, high quality photography, professional lighting, detailed jewelry rendering, photorealistic, 4k resolution`;
    
    const result = await fal.subscribe("fal-ai/flux-pro/kontext", {
      input: {
        prompt: enhancedPrompt,
        image_url: jewelryImageUrl,
        num_inference_steps: 28,
        guidance_scale: 3.5,
        image_size: "portrait_4_3" as const,
        enable_safety_checker: true,
      }
    });

    if (!result.data?.images || result.data.images.length === 0) {
      throw new Error("No images generated by FLUX Kontext Pro");
    }

    return result.data.images[0].url;
  } catch (error) {
    console.error("‚ùå FLUX Kontext Pro generation failed:", error);
    throw error;
  }
}

// Virtual try-on using Bria Product Shot
async function tryOnVirtually(personImageUrl: string, jewelryImageUrl: string, prompt?: string): Promise<string> {
  console.log(`üë§ Performing virtual try-on with Bria Product Shot`);
  
  try {
    const scenePrompt = prompt 
      ? `${prompt}, person wearing jewelry, professional photography, realistic placement, proper lighting, high resolution`
      : `person wearing elegant jewelry, professional portrait photography, realistic jewelry placement, natural lighting, high quality`;
    
    const result = await fal.subscribe("fal-ai/bria/product-shot", {
      input: {
        image_url: jewelryImageUrl,
        scene_description: scenePrompt,
        ref_image_url: personImageUrl,
        optimize_description: true,
        num_results: 1,
        fast: true,
        placement_type: "automatic",
        shot_size: [1024, 1024],
      }
    });
    
    if (!result.data?.images || result.data.images.length === 0) {
      throw new Error("No images generated by Bria Product Shot");
    }
    
    return result.data.images[0].url;
  } catch (error) {
    console.error(`‚ùå Virtual try-on failed:`, error);
    throw error;
  }
}

export async function POST() {
  try {
    // Create a temporary worker to process one job
    const worker = new Worker('image-generation', async (job) => {
      console.log('Processing job:', job.id);
      
      const { imageUrl, personImage, prompt } = job.data;
      
      try {
        let finalImageUrl: string;
        
        if (personImage) {
          // Virtual try-on mode
          const processedPersonImage = await removePersonBackground(personImage);
          finalImageUrl = await tryOnVirtually(processedPersonImage, imageUrl, prompt);
        } else if (prompt) {
          // Prompt mode with jewelry reference
          finalImageUrl = await generateWithJewelryReference(imageUrl, prompt);
        } else {
          throw new Error("Either 'prompt' or 'personImage' must be provided");
        }
        
        return {
          imageUrl: finalImageUrl,
          success: true,
        };
      } catch (error) {
        console.error('Job processing error:', error);
        throw error;
      }
    }, { 
      connection: redis,
      concurrency: 1,
    });

    // Wait for a job and process it
    let processed = 0;
    
    // Check for waiting jobs and process one
    const waitingJobs = await imageQueue.getWaiting();
    if (waitingJobs.length > 0) {
      console.log(`Found ${waitingJobs.length} waiting jobs, processing one...`);
      
      // Let the worker run for a short time to process jobs
      await new Promise((resolve) => {
        let jobProcessed = false;
        
        worker.on('completed', async (job) => {
          console.log(`Job ${job.id} completed successfully`);
          processed++;
          jobProcessed = true;
          resolve(true);
        });
        
        worker.on('failed', async (job, err) => {
          console.error(`Job ${job?.id} failed:`, err);
          jobProcessed = true;
          resolve(false);
        });
        
        // Timeout after 60 seconds
        setTimeout(() => {
          if (!jobProcessed) {
            console.log('Worker timeout reached');
            resolve(false);
          }
        }, 60000);
      });
    }

    await worker.close();
    return NextResponse.json({ 
      success: true, 
      processed,
      message: processed > 0 ? `Processed ${processed} job(s)` : 'No jobs to process'
    });

  } catch (error) {
    console.error('Worker error:', error);
    return NextResponse.json({ 
      error: 'Worker processing failed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

export async function GET() {
  try {
    // Health check endpoint
    await redis.ping();
    const waiting = await imageQueue.getWaiting();
    const active = await imageQueue.getActive();
    
    return NextResponse.json({
      status: 'healthy',
      redis: 'connected',
      waiting: waiting.length,
      active: active.length,
    });
  } catch (error) {
    return NextResponse.json({
      status: 'unhealthy',
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
} 